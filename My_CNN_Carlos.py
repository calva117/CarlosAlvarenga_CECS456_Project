#Note from Carlos:
#     Derived from:
#        https://github.com/Coding-Lane/Image-Classification-CNN-Keras/blob/main/Solution%20-%20CNN%20Image%20Classification.ipynb

# -*- coding: utf-8 -*-
"""Solution - CNN Image Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13s1SMwD-vJ0YJibOB_nzgD9s1axzNLBl
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten
import cv2

class My_CNN_Carlos:

    def __init__(self, rearData, forwardData):
        #random.shuffle(rearData)
        #random.shuffle(forwardData)

        train_test_ratio = 0.83
        X_train = []
        X_test = []
        Y_train = []
        Y_test = []

        rearSample = []
        dataLen = len(rearData)
        stop = train_test_ratio*dataLen
        for idx, val in enumerate(rearData):
            #if idx/dataLen < dataLen*train_test_ratio:
            if idx < stop:
                X_train.append(val)
                Y_train.append([0.])
            else:
                X_test.append(val)
                Y_test.append([0.])
                rearSample.append(val)

        forwardSample = []
        dataLen = len(forwardData)
        stop = train_test_ratio * dataLen
        for idx, val in enumerate(forwardData):
            #if idx/dataLen < dataLen*train_test_ratio:
            if idx < stop:
                X_train.append(val)
                Y_train.append([1.])
            else:
                X_test.append(val)
                Y_test.append([1.])
                forwardSample.append(val)

        print("Percent", len(X_train)/(len(X_train)+len(X_test)))

        # X_train = np.array(X_train)
        # X_test = np.array(X_test)
        # Y_train = np.array(Y_train)
        # Y_test = np.array(Y_test)
        # forwardSample = np.array(forwardData)
        X_train = np.asfarray(X_train)
        X_test = np.asfarray(X_test)
        Y_train = np.asfarray(Y_train)
        Y_test = np.asfarray(Y_test)
        forwardSample = np.asfarray(forwardSample)

        """# Load Dataset"""

        #X_train = np.loadtxt('input.csv', delimiter=',') #NOTE X_train is 5x the size of X_test
        #Y_train = np.loadtxt('labels.csv', delimiter=',')

        #X_test = np.loadtxt('input_test.csv', delimiter=',')
        #Y_test = np.loadtxt('labels_test.csv', delimiter=',')

        #print("X_train size", len(X_train))
        #print("X_test size", len(X_test))

        #X_train = X_train.reshape(len(X_train), 100, 100, 3)
        #Y_train = Y_train.reshape(len(Y_train), 1)

        #X_test = X_test.reshape(len(X_test), 100, 100, 3)
        #Y_test = Y_test.reshape(len(Y_test), 1)

        #cv2.imshow('frja', X_train[0])
        #cv2.waitKey(1)
        #X_train = X_train / 255.0
        #X_test = X_test / 255.0

        divisor = 255.0

        for idx, val in enumerate(X_train):
            X_train[idx] = np.asfarray(val)/divisor
        for idx, val in enumerate(X_test):
            X_test[idx] = np.asfarray(val)/divisor
        for idx, val in enumerate(forwardSample):
            forwardSample[idx] = np.asfarray(val)/divisor
        for idx, val in enumerate(rearSample):
            rearSample[idx] = np.asfarray(val)/divisor

        for i in X_train[0]:
            for v in i:
                for j in v:
                    if j >0 and j < 1:
                        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")

        #imgToShow = cv2.resize(X_train[0], (400,400))
        #cv2.imshow("shouldBeBlack", imgToShow)
        #cv2.waitKey(10000)



        print("Shape of X_train: ", X_train.shape)
        print("Shape of Y_train: ", Y_train.shape)
        print("Shape of X_test: ", X_test.shape)
        print("Shape of Y_test: ", Y_test.shape)

        idx = random.randint(0, len(X_train))
        imgTest = X_train[idx, :]
        imgTest = imgTest*255.0
        #cv2.imshow("imgTest", imgTest)
        #cv2.waitKey(1000)
        #plt.imshow(imgTest)
        #plt.imshow(X_train[idx, :])
        #plt.show()

        """# Model"""

        squareImgWidth = 96

        model = Sequential([
            #Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)),
            Conv2D(32, (3, 3), activation='relu', input_shape=(squareImgWidth, squareImgWidth, 3)),
            MaxPooling2D((2, 2)),

            Conv2D(32, (3, 3), activation='relu'),
            MaxPooling2D((2, 2)),

            Flatten(),
            Dense(64, activation='relu'),
            Dense(1, activation='sigmoid')
        ])

        # model = Sequential()
        # model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)))
        # model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)))
        # model.add(MaxPooling2D((2, 2)))
        #
        # model.add(Conv2D(32, (3, 3), activation='relu'))
        # model.add(MaxPooling2D((2, 2)))
        #
        # model.add(Flatten())
        # model.add(Dense(64, activation='relu'))
        # model.add(Dense(1, activation='sigmoid'))

        model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

        #print("type(X_train)", type(X_train))
        #print("type(X_train[0])", type(X_train[0]))
        #print("type(Y_train)", type(Y_train))
        #print("type(Y_train[0])", type(Y_train[0]))
        #print("Y_train", Y_train)
        #print("Y_train[0]", Y_train[0])
        #print("Y_train[0][0]", Y_train[0][0])
        #testImg = X_train[0]
        #testImg = cv2.resize(testImg, (600, 600))
        #cv2.imshow("test", testImg)
        #cv2.waitKey(1)

        model.fit(X_train, Y_train, epochs=5, batch_size=64)

        print("Evaluation test sets")
        model.evaluate(X_test, Y_test)


        print("Making a prediction")
        """# Making predictions"""

        idx2 = random.randint(0, len(Y_test))
        imgTest = X_test[idx2, :]*255.0
        #plt.imshow(X_test[idx2, :])
        #plt.imshow(imgTest)
        print("Value is ", Y_test[idx2, :])
        plt.show()

        #y_pred = model.predict(X_test[idx2, :].reshape(1, 100, 100, 3))
        y_pred = model.predict(X_test[idx2, :].reshape(1, squareImgWidth, squareImgWidth, 3))
        y_pred = y_pred > 0.5

        if (y_pred == 0):
            pred = 'rear'
        else:
            pred = 'forward'

        for i in range(0,10):
            y_pred = model.predict(rearSample[i].reshape(1, squareImgWidth, squareImgWidth, 3))
            print(y_pred)
            y_pred = model.predict(forwardSample[i].reshape(1, squareImgWidth, squareImgWidth, 3))
            print(y_pred)
            print()

        print("Our model says it is a :", pred)

        model.save('myModel.h5')